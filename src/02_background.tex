\chapter{Background} \label{C:background} 
There are numerous concepts that surround Kihi that are
worth explaining for this discussion of a performance
driven implementation.
This chapter hopes to provide all the background
necessary for an undergraduate software engineer
to understand and appreciate the rest of the paper.
This section begins with a brief explanation of 
functional, concatenative, and compositional
programming paradigms.

\section{Functional Languages}
Functional programming languages are defined by their use
of function evaluation as the primary means of computation.
This stands in contrast to imperative programming languages
such as Java which represents computation as a series of 
statements. The distinguishing factor being that statements
are capable of manipulating state whereas functions,
in a functional context, cannot.
In that sense functional functions are more similar to imperative
expressions than imperative functions.

Many mainstream programming languages support first-class functions and thus support programming in a functional style. However, whether they are considered functional programming languages is largely determined by the dominant programming style of the community. For instance, while Java 8+ supports programming in a functional style it is still typically considered an object orientated language. Figure
\ref{fig:imperative_vs_functional_example} illustrates this by showing a imperative and functional approach to finding the sum
of a list in Java.

\todo[inline]{Address purity, reference haskell book}


\input{figures/02_background/imperative_vs_functional_example.tex}


\section{Concatenative and compositional languages}
Concatenative and compositional are two labels that are often used in tandem when describing a programming language. The first label is used to describe a programming languages where the source code of two programs can be concatenated together into a meaningful program, and the second a language where the juxtaposition of terms denotes function composition. These labels are often found together because these properties are closely associated. Any language that is compositional can easy express pipeline processes by simply enumerating the stages. It is then also clear that the source code of such programs can also be concatenated to form a larger pipeline with the combined stages of the two.

\todo[inline]{Do concrete example if Forth or something, also find a reference}

\section{Kihi}
The Kihi programming language is the focus of this report so it is worthwhile to explain its structure and operation in detail. This section begins with an explanation of the language's grammar which is followed by an exploration of two ways a Kihi program can be executed.

\subsection{Grammar}
As previous mentioned, Kihi consists of only six types of terms: one value type and five operators that can manipulate values. The value type, more commonly referred to as an abstraction, is a Kihi program captured by parenthesis. The is illustrated by figure \ref{fig:kihi_grammar} which shows the formal grammar of Kihi and figure \ref{fig:kihi_example} which provides an example of a Kihi program.

\input{figures/02_background/kihi_grammar.tex}
\input{figures/02_background/kihi_example.tex}
\todo[inline]{Add citation for the counting program?}
\todo[inline]{Provide examples of how the operators work}
\todo[inline]{The exact behaviour of the operators are described later}

\subsection{Kihi Evaluation Methods}

\subsection{Kihi Operational Semantics}



Either
one of five operators or an abstraction: a sequence of Kihi terms
captured by parenthesis. 

The complete grammar for the language is given
in figure \ref{fig:grammar}. The semantics of the language make it
interesting from a research perspective. The limited expressiveness of
the language prevents the common approach to optimisation where expressive
abstractions can be compiled to efficient machine code. [cite static
dispatch optimisation]. Furthermore, the abstractions/semantics of Kihi are
also far disjoined from bare metal. This incurs the additional overhead of
mapping Kihi to machine instructions.

It limits the space of possible
optimisations and is also far detracted from actual bare metal instructions.


\begin{figure}
    \centering
    \begin{enumerate}
        \item \textbf{Apply} releases the sequence of terms captured by an abstraction.
        \item \textbf{Left} places the second abstraction at the start of the first
        \item \textbf{Right} places the second abstraction at the end of the first
        \item \textbf{Copy} copies an abstraction
        \item \textbf{Drop} deletes an abstraction
    \end{enumerate}
    \caption{English explanation of operators}
    \label{fig:operator explanation}
\end{figure}

Of these terms, only one acts as a value

\section{Execution Style}
There are two main execution styles that can be used to execute
a Kihi program: a term rewriting approach and a stack based 
approach. These two approachs are identical for side-effect
free and terminating programs, however, the observed
behaviour for other varieties of programs can differ
substantially depending on the execution style. The rest of 
this section describes these two execution styles and 
concludes by contrasting their behaviour.

\subsubsection{Term Rewriting}
Term rewriting is the process of finding
and replacing reducible terms with their reduced form. For Kihi,
this means finding terms which are directly followed by
some number of abstractions. The specific number of abstractions
required is determined by the term and can be thought of as the
number of arguments. This execution paradigm allows execution
to occur anywhere in the program because a reducible term may
be found anywhere in the program and this reduction can be
thought of as an execution step.

The operational semantics for a term rewriting based execution of
Kihi is shown is figure \ref{fig:term_rewriting_op_sem}.

\input{figures/04_implementation/term_rewriting_op_sem.tex}
\input{figures/04_implementation/stack_op_sem.tex}


\subsubsection{Stack Based}
Stack based execution is a model of execution where each term
has a specfic effect on a global stack. The terms are typically
either processed in a right to left order or vice versa. This
restricts execution to the rightmost or leftmost term. Furthermore,
the use of stack restricts the arguments accessible to each term.
Stack based execution imagines the terms of the program as
instructions for a stack machine. The terms are scanned
right to left and an action performed depending on the term
encountered. For instance, whenever an abstraction is found
it is pushed onto the stack and whenever a drop is found the
topmost value of the stack is popped and discarded.

\subsubsection{Differences}
The most fundamental difference these methods of execution is
revealed when term rewriting is broken down into two fundamental steps.

1. Seek
    - Find the term to execute
2. Execution
    - Execute that term

In contrast, stack based methods do not involve a seek phase. This
can significantly improve performance, but also shows that stack
based systems are a subset of term rewriting based systems. In fact,
a term rewriting based system seeking from right to left is usually 
equivilent to a stack based system when the program. The edgecase
being when the program being executed contains barriers. In this case,
term rewriting based systems are able to find executable portions
beyond the barrier.

A term rewriting based virtual machine will be able to execute
all programs a stack based machine is able to. The proof of this
is relatively simple. One can imagine a term rewriting machine 
that searches for reducible terms right to left as equivilent to
a stack machine for terminating programs.



A program representing an infinite data structure, such as the count
program which outputs a continous stream of numbers, cannot be
processed through a normal stack based approach. There may be alterations
to the stack based approach which may allow values to be pushed 
through to the left hand side of the program.


an abstraction is
encountered it is pushed onto the stack and when a term (reword)
is found the arguments are popped off the stack and the 
result, if it is an abstraction, is pushed onto the stack.

The first approach involves finding and replacing
reducible terms with their reduced form. The essence of this
execution style is shown in figure 
\ref{fig:term_rewriting_pseudocode} which provides a pseudocode
description of the essential algorithm.

These two different approaches are identical for
terminating programs but can display very different behaviour
for non-terminating programs.
Any acknowledgments should go 
in here, between the title page and the table of contents.  The 
acknowledgments do not form a proper chapter, and so don't get a 
number or appear in the table of contents.
