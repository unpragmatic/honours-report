\chapter{Notes}\label{C:notes}

future work could involve finding a better data structure.
There are a lot of heap allocations that can be removed.
This can also be done by using a better encoding that is able
to better reuse symbols

todo make numbers work in a flat hierachy  (i.e. do no preprocess) done?

Could design an interpreter that uses stack until a value is requested. When a
value is requested then left reduce could be used.

Combine the tree encoding technology with the stack execution technology.in

Arity analysis would played with but not tangible results were found.

Future work could also include adding a JIT compiler to the left reduce based version.z


Mixture of stack based execution and reduction.
Use seek to find a spot to stack execute from.

Add symbolic execution to the stack model.

Perfor multi pass optimisation of symbols.

Combine symbols that can be combined. i.e. s1 :: 2 arg -> 0 , s2 :: 0 arg -> 1 arg => s1 s2 :: 1 arg -> 0



These two terms are often used to refer to similar concepts. Whereas, a compositional language implies that the juxtaposition of terms denotes function composition. This again stands in contrast to what are commonly termed as applicative languages, such as Haskell, where the juxtaposition of terms denotes
function application.

Together these properties describe a language where individual terms are simply stages in a pipeline. For instance, in such a language the program: abc, might describe a program that takes
input X and outputs input Y and the program: def might describe a program that takes input Y and outputs Z. Then the program: abcdef is a program that takes input X and outputs Z.

A compositional language is one where the default mode of operation
is the composition of functions. For instance,...
The typical way of thinking in such languages, such as Om and Forth,
is to imagine a stack, real or otherwise, being pass from each term
to the next.

Another common property of this class of languages is that evaluation
is typically performed left to right, in contrast to Kihi which is
evaluated right to left.

The confusion arises due to the fact that concatenative languages are
almost always also compositional.
While, concatenative languages are often compositional 



Either
one of five operators or an abstraction: a sequence of Kihi terms
captured by parenthesis. 

The complete grammar for the language is given
in figure \ref{fig:grammar}. The semantics of the language make it
interesting from a research perspective. The limited expressiveness of
the language prevents the common approach to optimisation where expressive
abstractions can be compiled to efficient machine code. [cite static
dispatch optimisation]. Furthermore, the abstractions/semantics of Kihi are
also far disjoined from bare metal. This incurs the additional overhead of
mapping Kihi to machine instructions.

It limits the space of possible
optimisations and is also far detracted from actual bare metal instructions.


This process can be parametrised on the specific symbol detection and symbol optimisation process, however the Kihi Runner only provides two symbol detection algorithms and one symbol optimisation algorithm.

Symbol optimisation amounts to dynamically computing an more efficient representation of terms. 

This is process is also illustrated in figure \ref{fig:kihi_execution_process}. This process is similar to classical pinhole optimisation techniques where sequences of instructions are replaced with semantically equivalent but more efficient instructions.


\todo[inline]{Future work: implement number specific detection and compare performance}



\todo[inline]{Motivate the design and implementation sections}

However firstly, the report begins with an introduction to the Kihi language in chapter \ref{C:background}. This includes an explanation of the language and its origins and also a brief overview of surrounding material such as related programming paradigms. Readers familiar with this material may skip to chapter \ref{C:implementation} which discussed the heart of the project: the implementation. This includes details of the implementation's design and the optimisation techniques used to improve performance. Most interestingly, section \ref{sec:implementation_optimisation} introduces the aforementioned optimisation technique capable of dynamically finding more efficient representations of programs.

\todo[inline]{
    Move to background:
In addition, the operational semantics of the language do not
resemble actual bare metal instructions.

These qualities make it an 
interesting subject for optimisation, in particular, the large
valley of abstraction between the program semantics and bare
metal brings about many challenges and opportunities.
}


In order to understand rest of the report proper treatment must be given to the surrounding background material.  Kihi a language with many traits. The uniqueness of Kihi arises from its combination of uncommon traits.

Kihi is a language 

The roots of Kihi lie in concatenative, compositional, and functional programming --- paradigms that are not commonly associated with mainstream languages let alone in conjunction. It is worthwhile to understand these various programming paradigms in order to understand why Kihi exists and encourage an appreciation of the technical challenges of the project. The goal of this chapter is to provide the background necessary for an undergraduate software engineering student
to understand the rest of this report. This starts with an introduction to the aforementioned programming paradigms, before delving into the details of Kihi itself.