\chapter{Notes}\label{C:notes}

future work could involve finding a better data structure.
There are a lot of heap allocations that can be removed.
This can also be done by using a better encoding that is able
to better reuse symbols

todo make numbers work in a flat hierachy  (i.e. do no preprocess) done?

Could design an interpreter that uses stack until a value is requested. When a
value is requested then left reduce could be used.

Combine the tree encoding technology with the stack execution technology.in

Arity analysis would played with but not tangible results were found.

Future work could also include adding a JIT compiler to the left reduce based version.z


Mixture of stack based execution and reduction.
Use seek to find a spot to stack execute from.

Add symbolic execution to the stack model.

Perfor multi pass optimisation of symbols.

Combine symbols that can be combined. i.e. s1 :: 2 arg -> 0 , s2 :: 0 arg -> 1 arg => s1 s2 :: 1 arg -> 0



These two terms are often used to refer to similar concepts. Whereas, a compositional language implies that the juxtaposition of terms denotes function composition. This again stands in contrast to what are commonly termed as applicative languages, such as Haskell, where the juxtaposition of terms denotes
function application.

Together these properties describe a language where individual terms are simply stages in a pipeline. For instance, in such a language the program: abc, might describe a program that takes
input X and outputs input Y and the program: def might describe a program that takes input Y and outputs Z. Then the program: abcdef is a program that takes input X and outputs Z.

A compositional language is one where the default mode of operation
is the composition of functions. For instance,...
The typical way of thinking in such languages, such as Om and Forth,
is to imagine a stack, real or otherwise, being pass from each term
to the next.

Another common property of this class of languages is that evaluation
is typically performed left to right, in contrast to Kihi which is
evaluated right to left.

The confusion arises due to the fact that concatenative languages are
almost always also compositional.
While, concatenative languages are often compositional 



Either
one of five operators or an abstraction: a sequence of Kihi terms
captured by parenthesis. 

The complete grammar for the language is given
in figure \ref{fig:grammar}. The semantics of the language make it
interesting from a research perspective. The limited expressiveness of
the language prevents the common approach to optimisation where expressive
abstractions can be compiled to efficient machine code. [cite static
dispatch optimisation]. Furthermore, the abstractions/semantics of Kihi are
also far disjoined from bare metal. This incurs the additional overhead of
mapping Kihi to machine instructions.

It limits the space of possible
optimisations and is also far detracted from actual bare metal instructions.


This process can be parametrised on the specific symbol detection and symbol optimisation process, however the Kihi Runner only provides two symbol detection algorithms and one symbol optimisation algorithm.

Symbol optimisation amounts to dynamically computing an more efficient representation of terms. 

This is process is also illustrated in figure \ref{fig:kihi_execution_process}. This process is similar to classical pinhole optimisation techniques where sequences of instructions are replaced with semantically equivalent but more efficient instructions.


\todo[inline]{Future work: implement number specific detection and compare performance}