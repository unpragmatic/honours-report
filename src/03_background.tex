\chapter{Background} \label{C:background} 

\section{Kihi}
The Kihi programming language consists of only six types of terms. Either
one of five operators or an abstraction: a sequence of Kihi terms
captured by parenthesis. 

The complete grammar for the language is given
in figure \ref{fig:grammar}. The simplicity of the language makes it
interesting from a research perspective. It limits the space of possible
optimisations and is also far detracted from actual bare metal instructions.





todo make numbers work in a flat hierachy  (i.e. do no preprocess)
\begin{figure}[htb]       
    \centering
    \begin{grammar}
    <program> ::= { <term> }

    <abstraction> ::= '(' <term> ')'

    <term> ::= <abstraction>
        \alt 'apply'
        \alt 'left'
        \alt 'right'
        \alt 'copy'
        \alt 'drop'
    
      \end{grammar}
    \caption{}
    \label{fig:grammar}
\end{figure}


Could design an interpreter that uses stack until a value is requested. When a
value is requested then left reduce could be used.

Combine the tree encoding technology with the stack execution technology.in

Arity analysis would played with but not tangible results were found.

Future work could also include adding a JIT compiler to the left reduce based version.z


\begin{figure}
    \centering
    \begin{enumerate}
        \item \textbf{Apply} releases the sequence of terms captured by an abstraction.
        \item \textbf{Left} places the second abstraction at the start of the first
        \item \textbf{Right} places the second abstraction at the end of the first
        \item \textbf{Copy} copies an abstraction
        \item \textbf{Drop} deletes an abstraction
    \end{enumerate}
    \caption{English explanation of operators}
    \label{fig:operator explanation}
\end{figure}

Of these terms, only one acts as a value

\section{Execution Style}
There are two main execution styles that can be used to execute
a Kihi program: a term rewriting approach and a stack based 
approach. These two approachs are identical for side-effect
free and terminating programs, however, the observed
behaviour for other varieties of programs can differ
substantially depending on the execution style. The rest of 
this section describes these two execution styles and 
concludes by contrasting their behaviour.

\subsubsection{Term Rewriting}
Term rewriting is the process of finding
and replacing reducible terms with their reduced form. For Kihi,
this means finding terms which are directly followed by
some number of abstractions. The specific number of abstractions
required is determined by the term and can be thought of as the
number of arguments. This execution paradigm allows execution
to occur anywhere in the program because a reducible term may
be found anywhere in the program and this reduction can be
thought of as an execution step.

\subsubsection{Stack Based}
Stack based execution imagines the terms of the program as
instructions for a stack machine. The terms are scanned
right to left and an action performed depending on the term
encountered. For instance, whenever an abstraction is found
it is pushed onto the stack and whenever a drop is found the
topmost value of the stack is popped and discarded.

\subsubsection{Differences}
A term rewriting based virtual machine will be able to execute
all programs a stack based machine is able to. The proof of this
is relatively simple. One can imagine a term rewriting machine 
that searches for reducible terms right to left as equivilent to
a stack machine for terminating programs.

A program representing an infinite data structure, such as the count
program which outputs a continous stream of numbers, cannot be
processed through a normal stack based approach. There may be alterations
to the stack based approach which may allow values to be pushed 
through to the left hand side of the program.


an abstraction is
encountered it is pushed onto the stack and when a term (reword)
is found the arguments are popped off the stack and the 
result, if it is an abstraction, is pushed onto the stack.

The first approach involves finding and replacing
reducible terms with their reduced form. The essence of this
execution style is shown in figure 
\ref{fig:term_rewriting_pseudocode} which provides a pseudocode
description of the essential algorithm.

These two different approaches are identical for
terminating programs but can display very different behaviour
for non-terminating programs.
Any acknowledgments should go 
in here, between the title page and the table of contents.  The 
acknowledgments do not form a proper chapter, and so don't get a 
number or appear in the table of contents.
